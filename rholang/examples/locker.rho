new Locker, verify, toyVerify,
trace(`rho:io:stderr`), stdout(`rho:io:stdout`),
insertArbitrary(`rho:registry:insertArbitrary`), lookup(`rho:registry:lookup`)
in {
  // Test / demo
  new chairUriCh, voterUriCh, inboxUriCh, votedCh in {
    // Chair behavior from off-chain
    for(@chairURI <- chairUriCh; @inboxURI <- inboxUriCh) {
      trace!({"chairURI": chairURI, "inboxURI": inboxURI}) |
      new clCh, inlCh, ch in {
        lookup!(chairURI, *clCh) |
        lookup!(inboxURI, *inlCh) |

        for(chairLocker <- clCh; inbox <- inlCh) {
          // trace!({"chairLocker": *chairLocker}) |
          chairLocker!("cccc".hexToBytes(), 0,
            "giveRightToVote", Nil, *trace, *inbox) |
          for(_ <- votedCh) {
            chairLocker!("cccc".hexToBytes(), 1,
              "getWinner", Nil, *trace, *ch) | for(@(winner, tally) <- ch) {
              trace!({"winner": winner, "tally": tally})
            }
          }
        }
      }
    } |

    // Voter behavior from off-chain.
    new vlCh, ch in {
      for(@voterURI <- voterUriCh) {
        trace!({"voterURI": voterURI}) |
        lookup!(voterURI, *vlCh) |
        for(voterLocker <- vlCh) {
          // trace!({"voter locker": *voterLocker}) |
          voterLocker!("dddd".hexToBytes(), 1,
            "voteFor", "Rick", *trace, *ch) | for (_ <- ch) {
            votedCh!(Nil)
          }
        }
      }
    } |

    // Chair on-chain set-up.
    new seed, lockerCh, lookupCh, ackCh in {
      // ISSUE: how to manage registry URIs in eval mode?
      lookup!(`rho:id:sotmfszrhw7frtkd8e4i4gbderxi8aobh9w4zggxydnfuhwbbn1srx`,
        *lookupCh) | for(Ballot <- lookupCh) {

        Locker!("Chip the Chair's locker", "cc".hexToBytes(),

          // Note we're _sending_ this contract / for process,
          // not running it.
          for(return <- seed) {
            new bCh, self in {
              Ballot!(Set("Rick", "Morty"), *bCh) | for(chair, winner <- bCh) {

                // These are 0-ary and total, but they fit in
                // the 1-ary partial gateway
                contract self(@"giveRightToVote", _, ej, return) = {
                  chair!("giveRightToVote", *return)
                } |

                contract self(@"getWinner", _, ej, return) = {
                  winner!(*return)
                }
              } |
              return!(bundle+{*self})
            }
          },
          *seed,
          *lockerCh)
      } |

      for (@chairLocker <- lockerCh) {
        insertArbitrary!(bundle+{chairLocker}, *chairUriCh)
      }
    } |

    new seed, lockerCh in {
      Locker!("Vick the Voter's locker", "dd".hexToBytes(),

        // Note we're _sending_ this contract / for process,
        // not running it.
        for(return <- seed) {
          new self, rCh, inbox in {
            insertArbitrary!(bundle+{*inbox}, *rCh) | for(@uri <- rCh) {
              stdout!({"Vick's inbox registerd at": uri}) |

              contract self(@"voteFor", @choice, ej, ack) = {
                trace!({"voteFor": choice}) |
                for(rightToVote <- inbox) {
                  rightToVote!("vote", choice, *ej, *ack)
                }
              } |

              // These two could / should be public,
              // i.e. callable without a signature.
              // The caller / owner can expose it.
              contract self(@"inbox", _, _ej, return) = {
                return!(bundle+{*inbox})
              } |
              contract self(@"inboxAddress", _, _ej, return) = {
                // trace!({"getting inbox address": uri}) |
                return!(uri)
              }
            } |
            return!(bundle+{*self})
          }
        },
        *seed,
        *lockerCh) |
      for (voterLocker <- lockerCh) {
        insertArbitrary!(bundle+{*voterLocker}, *voterUriCh) |
        voterLocker!("dddd".hexToBytes(), 0,
          "inboxAddress", Nil, *trace, *inboxUriCh)
      }
    }
  } |
  // end test / demo


  new uriCh in {
    insertArbitrary!(bundle+{*Locker}, *uriCh) | for(@uri <- uriCh) {
      stdout!({"Locker registry uri": uri})
    }
  }
  |

  // WARNING: if sig is the wrong size, we get a java.lang.RuntimeException,
  // and our nonceCh is stuck.
  contract verify(
    @{sig /\ ByteArray},  // ed25519 signature of blakeb256Hash of nextNonce.toByteArray()
    @{pk /\ ByteArray},
    @{nonce /\ Int},  // claimed next nonce
    nonceCh,              // real nonce storage
    @data,                // data to be signed (along with nonce)
    eject,                // failure path (bad nonce or signature)
    ack                   // sig OK path
  ) = {
    // trace!({"verify sig": sig, "pk": pk, "nonce": nonce}) |
    for(@prevNonce <- nonceCh) {
      // trace!({"prevNonce": prevNonce}) |
      if (nonce == (prevNonce + 1)) {
        new result, hashOut in {
          @"blake2b256Hash"!((nonce, data).toByteArray(), *hashOut) |
          for(@hash <- hashOut) {
            // trace!({"hash": hash}) |
            @"ed25519Verify"!(hash, sig, pk, *result) | for(@r <- result) {
              // trace!({"verify": r}) |
              if (r) { nonceCh!(nonce) | ack!(Nil) }
              else { nonceCh!(prevNonce) | eject!("bad ed25519 signature") }
            }
          }
        }
      } else {
        // ISSUE: having the locker's nickname in the diagnostic would be nice
        nonceCh!(prevNonce) | eject!({"expected nonce": prevNonce + 1})
      }
    }
  } |

  // toy signature verification: checks that sig == pk ++ pk
  contract toyVerify(
    @{sig /\ ByteArray}, @{pk /\ ByteArray}, @{nonce /\ Int}, nonceCh,
    @data,
    eject, ack) = {
    // trace!({"verify sig": sig, "pk": pk, "data": data}) |
    for(@prevNonce <- nonceCh) {
      // trace!({"prevNonce": prevNonce}) |
      if (nonce == (prevNonce + 1)) {
        if (pk ++ pk == sig) { nonceCh!(nonce) | ack!(Nil) }
        else { nonceCh!(prevNonce) | eject!("bad ++ sig") }
      } else {
        nonceCh!(prevNonce) | eject!({"expected nonce": prevNonce + 1})
      }
    }
  } |

  contract Locker(
    @{label /\ String},
    @{pubKey /\ ByteArray},
    @seedCode, seedEntry,
    return) = {
    trace!({"Locker": label, "pubKey": pubKey}) |

    new self, seedCh, nonceCh in {
      nonceCh!(-1) |

      return!(*self) |

      contract self(@"getNonce", return) = { for(@nonce <- nonceCh) {
        nonceCh!(nonce) | // peek
        return!(nonce)
      } } |

      seedCode |
      seedEntry!(*seedCh) | for (seed <- seedCh) {
        // trace!({"seed": *seed}) |

        // unary, partial
        contract self(
          @{sig /\ ByteArray}, @{nonce /\ Int},
          @{method /\ String}, @arg, eject, ret
        ) = {
          // trace!({"gateway1p": method, "arg": arg}) |
          new okCh in {
            // TODO: replace toyVerify by real verify
            toyVerify!(sig, pubKey, nonce, *nonceCh,
              (method, arg, *eject, *ret), *eject, *okCh) |
            for(_ <- okCh) {
              // trace!({"sig ok": sig}) |
              seed!(method, arg, *eject, *ret)
            }
          }
        }
      }
    }
  }
}
