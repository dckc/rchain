new Locker, verify, toyVerify,
trace(`rho:io:stderr`), stdout(`rho:io:stdout`),
insertArbitrary(`rho:registry:insertArbitrary`), lookup(`rho:registry:lookup`)
in {
  // Test / demo
  new seed, echo, lockerCh, ackCh in {
    Locker!("echoTick", "aabb".hexToBytes(),
      // Note we're _sending_ this contract / for process,
      // not running it.
      for(return <- seed) {
        new tickCh in {
          tickCh!(0) |
          contract echo(@"echo", @input, ej, ack) = {
            for(@tick <- tickCh) {
              tickCh!(tick + 1) |
              trace!({"input": input, "tick": tick}) |
              ack!(Nil)
            }
          }
        } |
        return!(*echo)
      },
      *seed,
      *lockerCh) |
    // echo is unary (after method name), partial
    for (lockedEcho <- lockerCh) {
      lockedEcho!("aabbaabb".hexToBytes(), 0, "echo", 123, *trace, *ackCh) |
      for(@ack <- ackCh) {
        trace!({"ack1": ack}) |
        lockedEcho!("aabbaabb".hexToBytes(), 1, "echo", 456, *trace, *ackCh) |
        for(@ack <- ackCh) {
          trace!({"ack2": ack})
        }
      }
    }
  } |

  new uriCh in {
    insertArbitrary!(bundle+{*Locker}, *uriCh) | for(@uri <- uriCh) {
      stdout!({"Locker registry uri": uri})
    }
  }
  |

  // WARNING: if sig is the wrong size, we get a java.lang.RuntimeException,
  // and our nonceCh is stuck.
  contract verify(
    @{sig /\ ByteArray},  // ed25519 signature of blakeb256Hash of nextNonce.toByteArray()
    @{pk /\ ByteArray},
    @{nonce /\ Int},  // claimed next nonce
    nonceCh,              // real nonce storage
    @data,                // data to be signed (along with nonce)
    eject,                // failure path (bad nonce or signature)
    ack                   // sig OK path
  ) = {
    // trace!({"verify sig": sig, "pk": pk, "nonce": nonce}) |
    for(@prevNonce <- nonceCh) {
      // trace!({"prevNonce": prevNonce}) |
      if (nonce == (prevNonce + 1)) {
        new result, hashOut in {
          @"blake2b256Hash"!((nonce, data).toByteArray(), *hashOut) |
          for(@hash <- hashOut) {
            // trace!({"hash": hash}) |
            @"ed25519Verify"!(hash, sig, pk, *result) | for(@r <- result) {
              // trace!({"verify": r}) |
              if (r) { nonceCh!(nonce) | ack!(Nil) }
              else { nonceCh!(prevNonce) | eject!("bad ed25519 signature") }
            }
          }
        }
      } else {
        nonceCh!(prevNonce) | eject!({"expected nonce": prevNonce + 1})
      }
    }
  } |

  // toy signature verification: checks that sig == pk ++ pk
  contract toyVerify(
    @{sig /\ ByteArray}, @{pk /\ ByteArray}, @{nonce /\ Int}, nonceCh,
    @data,
    eject, ack) = {
    // trace!({"verify sig": sig, "pk": pk, "data": data}) |
    for(@prevNonce <- nonceCh) {
      // trace!({"prevNonce": prevNonce}) |
      if (nonce == (prevNonce + 1)) {
        if (pk ++ pk == sig) { nonceCh!(nonce) | ack!(Nil) }
        else { nonceCh!(prevNonce) | eject!("bad ++ sig") }
      } else {
        nonceCh!(prevNonce) | eject!({"expected nonce": prevNonce + 1})
      }
    }
  } |

  contract Locker(
    @{label /\ String},
    @{pubKey /\ ByteArray},
    @seedCode, seedEntry,
    return) = {
    trace!({"Locker": label, "pubKey": pubKey}) |

    new self, seedCh, nonceCh in {
      nonceCh!(-1) |

      return!(*self) |

      contract self(@"getNonce", return) = { for(@nonce <- nonceCh) {
        nonceCh!(nonce) | // peek
        return!(nonce)
      } } |

      seedCode |
      seedEntry!(*seedCh) | for (seed <- seedCh) {
        // trace!({"seed": *seed}) |

        // unary, partial
        contract self(
          @{sig /\ ByteArray}, @{nonce /\ Int},
          @{method /\ String}, @arg, eject, ret
        ) = {
          // trace!({"gateway1p": method, "arg": arg}) |
          new okCh in {
            // TODO: replace toyVerify by real verify
            toyVerify!(sig, pubKey, nonce, *nonceCh,
              (method, arg, *eject, *ret), *eject, *okCh) |
            for(_ <- okCh) {
              // trace!({"sig ok": sig}) |
              seed!(method, arg, *eject, *ret)
            }
          }
        }
      }
    }
  }
}
